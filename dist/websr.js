/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebSR"] = factory();
	else
		root["WebSR"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/context.ts":
/*!************************!*\
  !*** ./src/context.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass WebGPUContext {\n    constructor(device, resolution, canvas) {\n        this.device = device;\n        this.canvas = canvas;\n        this.resolution = resolution;\n        this.textures = {};\n        this.destroyed = false;\n        this.context = this.canvas.getContext('webgpu');\n        this.context.configure({\n            device: this.device,\n            format: navigator.gpu.getPreferredCanvasFormat()\n        });\n        this.debug = true;\n        this.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;\n        if (this.debug)\n            this.usage = this.usage | GPUTextureUsage.COPY_SRC;\n        this.textures['output'] = this.context.getCurrentTexture();\n    }\n    readTexture(textureName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.textures[textureName])\n                throw new Error(`No texture with name ${textureName}`);\n            const readEncoder = this.device.createCommandEncoder({\n                label: `Read ${textureName} texture encoder`,\n            });\n            const texture = this.textures[textureName];\n            let bitsPerPixel = 16;\n            if (texture.format === 'rgba8unorm')\n                bitsPerPixel = 4;\n            if (texture.format === 'r32float')\n                bitsPerPixel = 4;\n            const resultBuffer = this.device.createBuffer({\n                label: 'result buffer',\n                size: texture.width * texture.height * bitsPerPixel,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n            });\n            readEncoder.copyTextureToBuffer({\n                texture: this.textures[textureName],\n            }, {\n                buffer: resultBuffer,\n                bytesPerRow: texture.width * bitsPerPixel\n            }, {\n                width: texture.width,\n                height: texture.height,\n                depthOrArrayLayers: 1,\n            });\n            this.device.queue.submit([readEncoder.finish()]);\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\n            if (texture.format === 'r32float')\n                return new Float32Array(resultBuffer.getMappedRange());\n            else if (texture.format === 'rgba32float')\n                return new Float32Array(resultBuffer.getMappedRange());\n            else if (texture.format === 'rgba8unorm')\n                return new Uint8ClampedArray(resultBuffer.getMappedRange());\n            return new Float32Array(0);\n        });\n    }\n    destroy() {\n        this.device.destroy();\n        this.destroyed = true;\n    }\n    texture(key, options) {\n        if (!this.textures[key]) {\n            options = options || {};\n            this.textures[key] = this.device.createTexture({\n                label: key,\n                size: [options.width || this.resolution.width, options.height || this.resolution.height],\n                format: options.format || 'rgba32float',\n                usage: this.usage\n            });\n        }\n        return this.textures[key];\n    }\n}\nexports[\"default\"] = WebGPUContext;\n\n\n//# sourceURL=webpack://WebSR/./src/context.ts?");

/***/ }),

/***/ "./src/layers/anime4k/conv2d-3x4.ts":
/*!******************************************!*\
  !*** ./src/layers/anime4k/conv2d-3x4.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ../base_layer */ \"./src/layers/base_layer.ts\");\nclass Anime4KConv3x4 extends base_layer_1.default {\n    constructor(inputTextures, outputTexture, weights) {\n        super(inputTextures, outputTexture, weights);\n        this.label = \"Anime4KConv3x4\";\n        const kernels = weights.weights;\n        const bias = weights.bias;\n        this.createUniform(\"kernel_offsets\", \"array<vec4f, 9>\");\n        this.createUniform(\"kernels\", \"array<mat4x4f, 9>\");\n        this.createUniform(\"bias\", \"vec4f\");\n        this.shader = this.createStandardShader(`\n        \n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n                     var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                      \n                     for(var i = 0u; i < 9; i++){\n                       result += kernels[i]*textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i].xy));\n                    } \n                    \n                    result += bias;\n                  \n                    \n                    return result;\n                  }                 \n        `);\n        this.setUniform(\"kernel_offsets\", new Float32Array([\n            -1, -1, 0, 0,\n            -1, 0, 0, 0,\n            -1, 1, 0, 0,\n            0, -1, 0, 0,\n            0, 0, 0, 0,\n            0, 1, 0, 0,\n            1, -1, 0, 0,\n            1, 0, 0, 0,\n            1, 1, 0, 0,\n        ]));\n        this.setUniform(\"kernels\", new Float32Array(kernels));\n        this.setUniform(\"bias\", new Float32Array(bias));\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n    run() {\n        const encoder = this.device.createCommandEncoder({ label: this.label });\n        const pass = encoder.beginRenderPass(this.renderPassDescriptor);\n        pass.setPipeline(this.pipeline);\n        this.bindGroup = this.defaultBindGroup();\n        pass.setBindGroup(0, this.bindGroup);\n        pass.draw(6); // call our vertex shader 6 times\n        pass.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n}\nexports[\"default\"] = Anime4KConv3x4;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-3x4.ts?");

/***/ }),

/***/ "./src/layers/anime4k/conv2d-8x4.ts":
/*!******************************************!*\
  !*** ./src/layers/anime4k/conv2d-8x4.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ../base_layer */ \"./src/layers/base_layer.ts\");\nclass Anime4KConv8x4 extends base_layer_1.default {\n    constructor(inputTextures, outputTexture, weights) {\n        super(inputTextures, outputTexture, weights);\n        this.label = \"Anime4KConv8x4\";\n        const kernels = weights.weights;\n        const bias = weights.bias;\n        this.createUniform(\"kernel_offsets\", \"array<vec4f, 9>\");\n        this.createUniform(\"kernels\", \"array<mat4x4f, 18>\");\n        this.createUniform(\"bias\", \"vec4f\");\n        this.shader = this.createStandardShader(`\n        \n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n                     var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                      \n                     for(var i = 0u; i < 9; i++){\n                       result += kernels[i]*max(textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i].xy),0) , vec4f(0.0));\n                    }\n                    \n                     for(var i = 0u; i < 9; i++){\n                       result += kernels[i+9]*max(-1.0*textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i].xy), 0), vec4f(0.0));\n                    }  \n                    \n                    result += bias;\n                  \n                    \n                    return result;\n                  }                 \n        `);\n        this.setUniform(\"kernel_offsets\", new Float32Array([\n            -1, -1, 0, 0,\n            -1, 0, 0, 0,\n            -1, 1, 0, 0,\n            0, -1, 0, 0,\n            0, 0, 0, 0,\n            0, 1, 0, 0,\n            1, -1, 0, 0,\n            1, 0, 0, 0,\n            1, 1, 0, 0,\n        ]));\n        this.setUniform(\"kernels\", new Float32Array(kernels));\n        this.setUniform(\"bias\", new Float32Array(bias));\n        this.defaultSetup();\n    }\n}\nexports[\"default\"] = Anime4KConv8x4;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-8x4.ts?");

/***/ }),

/***/ "./src/layers/anime4k/display.ts":
/*!***************************************!*\
  !*** ./src/layers/anime4k/display.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ../base_layer */ \"./src/layers/base_layer.ts\");\nclass DisplayLayer extends base_layer_1.default {\n    constructor(inputTextures, outputTexture) {\n        super(inputTextures, outputTexture);\n        this.label = \"DisplayLayer\";\n        this.vertexScale = {\n            width: 1,\n            height: 1\n        };\n        this.shader = this.device.createShaderModule({\n            label: `${this.label}-shader`,\n            code: `\n            \n               ${this.defaultVertexShader()}\n              \n               @group(0) @binding(0) var pixelShuffle: texture_2d<f32>;\n               @group(0) @binding(1) var inputTexture: texture_external;\n               @group(0) @binding(2) var ourSampler: sampler;\n              \n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n              \n                    let x = i32(${this.resolution.width * 2}.0*(input.tex_coord.x));\n                    let y = i32(${this.resolution.height * 2}.0*(input.tex_coord.y));\n                    \n                    let value = textureLoad(pixelShuffle, vec2<i32>(x, y), 0).x;\n                    \n                    let bicubic = textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord);\n                    \n                    return bicubic + vec4f(value);\n                \n                  }            \n        `\n        });\n        this.sampler = this.device.createSampler({\n            addressModeU: \"repeat\",\n            addressModeV: \"repeat\",\n            magFilter: \"linear\",\n            minFilter: \"linear\",\n            mipmapFilter: \"linear\",\n        });\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n    defaultBindGroup() {\n        const entries = [];\n        this.inputTextures.forEach(function (texture, i) {\n            if (texture instanceof GPUExternalTexture) {\n                entries.push({ binding: i, resource: texture });\n            }\n            else if (texture instanceof GPUTexture) {\n                entries.push({ binding: i, resource: texture.createView() });\n            }\n        });\n        entries.push({ binding: this.inputTextures.length, resource: this.sampler });\n        return this.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries\n        });\n    }\n    setOutput(outputTexture) {\n        this.outputTexture = outputTexture;\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n}\nexports[\"default\"] = DisplayLayer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display.ts?");

/***/ }),

/***/ "./src/layers/anime4k/pixel-shuffle.ts":
/*!*********************************************!*\
  !*** ./src/layers/anime4k/pixel-shuffle.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ../base_layer */ \"./src/layers/base_layer.ts\");\nclass PixelShuffle2X extends base_layer_1.default {\n    constructor(inputTextures, outputTexture) {\n        super(inputTextures, outputTexture);\n        this.label = \"PixelShuffle2X\";\n        this.shader = this.device.createShaderModule({\n            label: `${this.label}-shader`,\n            code: `\n            \n            \n              struct VertexShaderOutput {\n                @builtin(position) position: vec4f,\n                @location(0) tex_coord: vec2f,\n              };\n\n            @vertex\n            fn vertexMain( @builtin(vertex_index) vertexIndex : u32) ->  VertexShaderOutput{\n                let pos = array(\n                // 1st triangle\n                vec2f( -1.0,  -1.0),  // center\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( -1.0,  1.0),  // center, top\n             \n                // 2st triangle\n                vec2f( -1.0,  1.0),  // center, top\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( 1.0,  1.0),  // right, top\n              );\n             \n              var vsOutput: VertexShaderOutput;\n              let xy = pos[vertexIndex];\n              vsOutput.position = vec4f(xy, 0.0, 1.0);\n              vsOutput.tex_coord = xy*0.5 + 0.5;\n              vsOutput.tex_coord.y = - 1.0* vsOutput.tex_coord.y  + 1.0;\n              vsOutput.tex_coord = vsOutput.tex_coord;\n              return vsOutput;\n            }\n          \n              \n               @group(0) @binding(0) var featureMap: texture_2d<f32>;\n\n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n                    let x_floor  = u32(fract(input.tex_coord.x*${this.resolution.width}.0)*2.0);\n                    \n                    let y_floor  = u32(fract(input.tex_coord.y*${this.resolution.height}.0)*2.0);\n                    \n                    //I don t know, I think this is right? I found this by trial and error\n                    let c_index: u32 = x_floor + y_floor*2;  \n              \n                    let x = i32(${this.resolution.width}.0*(input.tex_coord.x));\n                    let y = i32(${this.resolution.height}.0*(input.tex_coord.y));\n                    \n                    let value = textureLoad(featureMap, vec2<i32>(x, y), 0)[c_index];\n                   \n                    return vec4f(value, 0, 0, 0);\n                \n                  }            \n        `\n        });\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\n        this.bindGroup = this.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: [\n                { binding: 0, resource: this.inputTextures[0].createView() }\n            ]\n        });\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n}\nexports[\"default\"] = PixelShuffle2X;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/pixel-shuffle.ts?");

/***/ }),

/***/ "./src/layers/base_layer.ts":
/*!**********************************!*\
  !*** ./src/layers/base_layer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Layer {\n    constructor(inputTextures, outputTexture, weights) {\n        this.context = globalThis.context;\n        this.device = this.context.device;\n        this.resolution = this.context.resolution;\n        this.inputTextures = inputTextures;\n        this.outputTexture = outputTexture;\n        this.uniforms = [];\n        this.buffers = {};\n        this.weights = weights;\n        this.vertexScale = this.context.resolution;\n    }\n    defaultVertexShader() {\n        return `\n        \n             struct VertexShaderOutput {\n                @builtin(position) position: vec4f,\n                @location(0) tex_coord: vec2f,\n              };\n\n            @vertex\n            fn vertexMain( @builtin(vertex_index) vertexIndex : u32) ->  VertexShaderOutput{\n                let pos = array(\n                // 1st triangle\n                vec2f( -1.0,  -1.0),  // center\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( -1.0,  1.0),  // center, top\n             \n                // 2st triangle\n                vec2f( -1.0,  1.0),  // center, top\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( 1.0,  1.0),  // right, top\n              );\n             \n              var vsOutput: VertexShaderOutput;\n              let xy = pos[vertexIndex];\n              vsOutput.position = vec4f(xy, 0.0, 1.0);\n              vsOutput.tex_coord = xy*0.5 + 0.5;\n              vsOutput.tex_coord.y = - 1.0* vsOutput.tex_coord.y  + 1.0;\n               vsOutput.tex_coord.x =  vsOutput.tex_coord.x*${this.vertexScale.width};\n               vsOutput.tex_coord.y =  vsOutput.tex_coord.y*${this.vertexScale.height};\n              return vsOutput;\n            }\n        `;\n    }\n    createUniform(name, type) {\n        this.uniforms.push({ name, type });\n    }\n    defaultPipelineConfig() {\n        return {\n            label: `${this.label}-pipeline`,\n            layout: 'auto',\n            vertex: {\n                module: this.shader,\n                entryPoint: 'vertexMain',\n            },\n            fragment: {\n                module: this.shader,\n                entryPoint: 'fragmentMain',\n                targets: [{ format: this.outputTexture.format }],\n            },\n        };\n    }\n    defaultSetup() {\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\n        this.bindGroup = this.defaultBindGroup();\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n    defaultRenderPassDescriptor() {\n        return {\n            label: `${this.label}-render-pass`,\n            colorAttachments: [\n                {\n                    view: this.outputTexture.createView(),\n                    clearValue: [0, 0, 0, 1],\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                },\n            ],\n        };\n    }\n    createStandardShader(fragmentShader) {\n        return this.device.createShaderModule({\n            label: `${this.label}-shader`,\n            code: `\n          \n              ${this.defaultVertexShader()}\n              \n              ${this.fragmentShaderInputs()}\n              \n              ${fragmentShader}\n        `\n        });\n    }\n    fragmentShaderInputs() {\n        const inputs = [];\n        for (let i = 0; i < this.inputTextures.length; i++) {\n            let type = (this.inputTextures[i] instanceof GPUTexture) ? 'texture_2d<f32>' : 'texture_external';\n            inputs.push(`@group(0) @binding(0) var inputTexture${i}: ${type};`);\n        }\n        this.uniforms.forEach((uniform, i) => {\n            inputs.push(`@group(0) @binding(${i + this.inputTextures.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\n        });\n        return inputs.join('\\n');\n    }\n    setUniform(name, value) {\n        const buffer = this.device.createBuffer({\n            label: `layer-${this.label}-buffer-${name}`,\n            size: value.byteLength,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n        this.device.queue.writeBuffer(buffer, /*bufferOffset=*/ 0, value);\n        this.buffers[name] = buffer;\n    }\n    defaultBindGroup() {\n        const entries = [];\n        this.inputTextures.forEach(function (texture, i) {\n            if (texture instanceof GPUExternalTexture) {\n                entries.push({ binding: i, resource: texture });\n            }\n            else if (texture instanceof GPUTexture) {\n                entries.push({ binding: i, resource: texture.createView() });\n            }\n        });\n        this.uniforms.forEach((uniform, i) => {\n            entries.push({\n                binding: i + this.inputTextures.length,\n                resource: {\n                    buffer: this.buffers[uniform.name]\n                }\n            });\n        });\n        if (entries.length === 0)\n            return null;\n        return this.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries\n        });\n    }\n    hasExternalTexture() {\n        for (const texture of this.inputTextures) {\n            if (texture instanceof GPUExternalTexture)\n                return true;\n        }\n        return false;\n    }\n    run() {\n        const encoder = this.device.createCommandEncoder({ label: this.label });\n        const pass = encoder.beginRenderPass(this.renderPassDescriptor);\n        pass.setPipeline(this.pipeline);\n        if (this.hasExternalTexture()) {\n            this.bindGroup = this.defaultBindGroup();\n        }\n        if (this.bindGroup) {\n            pass.setBindGroup(0, this.bindGroup);\n        }\n        pass.draw(6); // call our vertex shader 6 times\n        pass.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n}\nexports[\"default\"] = Layer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/base_layer.ts?");

/***/ }),

/***/ "./src/layers/utils/gaussian.ts":
/*!**************************************!*\
  !*** ./src/layers/utils/gaussian.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ../base_layer */ \"./src/layers/base_layer.ts\");\nclass GuassianLayer extends base_layer_1.default {\n    constructor(inputTextures, outputTexture) {\n        super(inputTextures, outputTexture);\n        this.label = \"Gaussian\";\n        this.createUniform(\"gaussian\", \"array<vec3f, 3>\");\n        this.createUniform(\"kernel_offsets\", \"array<vec4f, 9>\");\n        this.shader = this.createStandardShader(`\n        \n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n                     var val  = 0.0;\n                      \n                     for(var i = 0u; i < 3; i++){\n                     \n                        let a = vec3f(\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x\n                        );\n                        \n                        val += dot(a, gaussian[i]);\n                      \n                    } \n                  \n                    \n                    return vec4f(val, val, val, 1.0);\n                  }                 \n        `);\n        this.setUniform(\"gaussian\", new Float32Array([\n            0.0675, 0.125, 0.0675, 0.0,\n            0.125, 0.250, 0.1250, 0.0,\n            0.0675, 0.125, 0.0675, 0.0\n        ]));\n        this.setUniform(\"kernel_offsets\", new Float32Array([\n            -1, -1, 0, 0,\n            0, -1, 0, 0,\n            1, -1, 0, 0,\n            -1, 0, 0, 0,\n            0, 0, 0, 0,\n            1, 0, 0, 0,\n            -1, 1, 0, 0,\n            0, 1, 0, 0,\n            1, 1, 0, 0,\n        ]));\n        this.defaultSetup();\n    }\n}\nexports[\"default\"] = GuassianLayer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/utils/gaussian.ts?");

/***/ }),

/***/ "./src/layers/utils/rgb_2_yuv.ts":
/*!***************************************!*\
  !*** ./src/layers/utils/rgb_2_yuv.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ../base_layer */ \"./src/layers/base_layer.ts\");\nclass RGB2YUV extends base_layer_1.default {\n    constructor(inputTextures, outputTexture) {\n        super(inputTextures, outputTexture);\n        this.createUniform(\"rgb2yuv\", \"mat3x3f\");\n        this.shader = this.createStandardShader(`\n        \n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n              \n                    let color = textureLoad(inputTexture0, vec2<i32>(input.tex_coord), 0);       \n                    let yuv = rgb2yuv*color.xyz;\n          \n                return vec4f(yuv, 1.0);\n              }     \n        `);\n        this.setUniform(\"rgb2yuv\", new Float32Array([\n            0.299, -0.1473, 0.615, 1.0,\n            0.587, -.2886, -.51499, 1.0,\n            0.114, 0.436, -.1001, 1.0\n        ]));\n        this.defaultSetup();\n    }\n}\nexports[\"default\"] = RGB2YUV;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/utils/rgb_2_yuv.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst context_1 = __webpack_require__(/*! ./context */ \"./src/context.ts\");\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \"./src/renderer.ts\");\nconst network_list_1 = __webpack_require__(/*! ./networks/network_list */ \"./src/networks/network_list.ts\");\nclass WebSR {\n    constructor(params) {\n        this.video = params.video;\n        // We should make this dynamic\n        this.resolution = {\n            width: this.video.videoWidth,\n            height: this.video.videoHeight\n        };\n        if (params.canvas)\n            this.canvas = params.canvas;\n        else {\n            this.canvas = new HTMLCanvasElement();\n            this.canvas.width = this.resolution.width * 2;\n            this.canvas.height = this.resolution.height * 2;\n        }\n        this.context = new context_1.default(params.gpu, this.resolution, this.canvas);\n        globalThis.context = this.context;\n        if (!network_list_1.NetworkList[params.network_name])\n            throw Error(`Network ${params.network_name} is not defined or implemented`);\n        this.network = new network_list_1.NetworkList[params.network_name](params.weights);\n        this.renderer = new renderer_1.default(this.network, this.video);\n    }\n    static initWebGPU() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!navigator.gpu)\n                return false;\n            const adapter = yield navigator.gpu.requestAdapter();\n            if (!adapter)\n                return false;\n            const device = yield adapter.requestDevice();\n            if (!device)\n                return false;\n            return device;\n        });\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.start();\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.stop();\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.stop();\n            this.context.destroy();\n        });\n    }\n}\nexports[\"default\"] = WebSR;\n\n\n//# sourceURL=webpack://WebSR/./src/main.ts?");

/***/ }),

/***/ "./src/networks/anime4k/cnn-2x-s.ts":
/*!******************************************!*\
  !*** ./src/networks/anime4k/cnn-2x-s.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \"./src/networks/base_network.ts\");\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \"./src/layers/anime4k/conv2d-3x4.ts\");\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \"./src/layers/anime4k/conv2d-8x4.ts\");\nconst pixel_shuffle_1 = __webpack_require__(/*! ../../layers/anime4k/pixel-shuffle */ \"./src/layers/anime4k/pixel-shuffle.ts\");\nconst display_1 = __webpack_require__(/*! ../../layers/anime4k/display */ \"./src/layers/anime4k/display.ts\");\nclass Anime4KCNN2XS extends base_network_1.default {\n    constructor(weights) {\n        super(weights);\n    }\n    model() {\n        const layers = [];\n        const weights = this.weights.layers;\n        const context = this.context;\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.texture('conv2d_tf'), weights['conv2d_tf']);\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.texture('conv2d_tf')], context.texture('conv2d_1_tf'), weights['conv2d_1_tf']);\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.texture('conv2d_1_tf')], context.texture('conv2d_2_tf'), weights['conv2d_2_tf']);\n        const conv2d_last_tf = new conv2d_8x4_1.default([context.texture('conv2d_2_tf')], context.texture('conv2d_last_tf'), weights['conv2d_last_tf']);\n        const pixel_shuffle = new pixel_shuffle_1.default([context.texture('conv2d_last_tf')], context.texture('pixel_shuffle', { width: context.resolution.width * 2, height: context.resolution.height * 2, format: \"r32float\" }));\n        const paint = new display_1.default([context.texture('pixel_shuffle'), context.input], context.texture('output'));\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_last_tf, pixel_shuffle, paint);\n        return layers;\n    }\n    feedForward(video) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.context.input = this.context.device.importExternalTexture({ source: video });\n            this.layers[0].inputTextures[0] = this.context.input;\n            this.layers[5].inputTextures[1] = this.context.input;\n            this.layers.forEach(function (layer) {\n                layer.run();\n            });\n        });\n    }\n}\nexports[\"default\"] = Anime4KCNN2XS;\n\n\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-s.ts?");

/***/ }),

/***/ "./src/networks/base_network.ts":
/*!**************************************!*\
  !*** ./src/networks/base_network.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass NeuralNetwork {\n    constructor(weights) {\n        this.weights = weights;\n        this.context = globalThis.context;\n        this.layers = this.model();\n    }\n    model() {\n        return [];\n    }\n    lastLayer() {\n        return this.layers[this.layers.length - 1];\n    }\n    feedForward(video) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.layers.forEach(layer => {\n                layer.run();\n            });\n        });\n    }\n}\nexports[\"default\"] = NeuralNetwork;\n\n\n//# sourceURL=webpack://WebSR/./src/networks/base_network.ts?");

/***/ }),

/***/ "./src/networks/network_list.ts":
/*!**************************************!*\
  !*** ./src/networks/network_list.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NetworkList = void 0;\nconst cnn_2x_s_1 = __webpack_require__(/*! ./anime4k/cnn-2x-s */ \"./src/networks/anime4k/cnn-2x-s.ts\");\nconst poc_network_1 = __webpack_require__(/*! ./poc_network */ \"./src/networks/poc_network.ts\");\nexports.NetworkList = {\n    \"anime4k/cnn-2x-s\": cnn_2x_s_1.default,\n    \"sb2702/blur-poc\": poc_network_1.default\n};\n\n\n//# sourceURL=webpack://WebSR/./src/networks/network_list.ts?");

/***/ }),

/***/ "./src/networks/poc_network.ts":
/*!*************************************!*\
  !*** ./src/networks/poc_network.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_network_1 = __webpack_require__(/*! ./base_network */ \"./src/networks/base_network.ts\");\nconst rgb_2_yuv_1 = __webpack_require__(/*! ../layers/utils/rgb_2_yuv */ \"./src/layers/utils/rgb_2_yuv.ts\");\nconst gaussian_1 = __webpack_require__(/*! ../layers/utils/gaussian */ \"./src/layers/utils/gaussian.ts\");\nclass PoCNetwork extends base_network_1.default {\n    constructor() {\n        super();\n    }\n    model() {\n        const layers = [];\n        const context = this.context;\n        layers.push(new rgb_2_yuv_1.default([context.texture('input')], context.texture('yuv')));\n        layers.push(new gaussian_1.default([context.texture('yuv')], context.texture('output')));\n        return layers;\n    }\n}\nexports[\"default\"] = PoCNetwork;\n\n\n//# sourceURL=webpack://WebSR/./src/networks/poc_network.ts?");

/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst display_1 = __webpack_require__(/*! ./layers/anime4k/display */ \"./src/layers/anime4k/display.ts\");\nclass WebSRRenderer {\n    constructor(network, video) {\n        this.context = globalThis.context;\n        this.network = network;\n        this.video = video;\n        this.active = false;\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.context.destroyed) {\n                throw new Error(\"WebSR instance was destroyed\");\n            }\n            this.active = true;\n            yield this.renderStep();\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.active = false;\n            if (this.vfc)\n                this.video.cancelVideoFrameCallback(this.vfc);\n        });\n    }\n    renderStep() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const lastLayer = this.network.lastLayer();\n            if (lastLayer instanceof display_1.default)\n                lastLayer.setOutput(this.context.context.getCurrentTexture());\n            yield this.render();\n            if (this.active) {\n                this.vfc = this.video.requestVideoFrameCallback(this.renderStep.bind(this));\n            }\n        });\n    }\n    render() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.network.feedForward(this.video);\n        });\n    }\n}\nexports[\"default\"] = WebSRRenderer;\n\n\n//# sourceURL=webpack://WebSR/./src/renderer.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});